<p>After taking a 13 year hiatus from KDE development, <a href="https://tube.kockatoo.org/w/exAQYJWrXoQSU1EDXidjr3">Harald Sitter's talk on KDE Linux</a> at Akademy 2024 was the perfect storm of nostalgia and inspiration to suck me back in. I've been contributing on and off since then.</p>

<p>This blog post outlines some gaping holes I see in its extensibility model, and how I plan to address them (assuming no objections from other developers).</p>

<div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhAIWvFSffjPJhDm2I3keS_kiZS0AV4UXS2g7_ZbhjrRQPRYJEvg_oyUUGV283K-MEcPejPXZJYgs0zxvVaVFWlnDAroGW8IG1mwOwhaVDPNVYBmu_E5UuS8uFaV73ZmHyKfSwjhueTfqkoAP3cjF54enTZK2jnyB7WWZWYVQfmTJZljRjxUhn1HjTH9AM/s4048/banana.jpg" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="2282" data-original-width="4048" height="180" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhAIWvFSffjPJhDm2I3keS_kiZS0AV4UXS2g7_ZbhjrRQPRYJEvg_oyUUGV283K-MEcPejPXZJYgs0zxvVaVFWlnDAroGW8IG1mwOwhaVDPNVYBmu_E5UuS8uFaV73ZmHyKfSwjhueTfqkoAP3cjF54enTZK2jnyB7WWZWYVQfmTJZljRjxUhn1HjTH9AM/s320/banana.jpg" width="320" /></a></div><br />

<h2 style="text-align: left;">The Problem</h2>

<p>KDE Linux is being built as an immutable OS without a traditional package manager. The strategy leans heavily on Flatpak for GUI applications, which (though, not without its problems) generally works well for its stated goal. But here's the thing: the Linux community has a relatively large population of CLI fanatics—developers who live in the terminal, who need <span style="font-family: monospace;">$OBSCURE_TOOL</span> for their workflow, who won't be satisfied with just what comes in a Flatpak.</p>

<p>The OS ships with a curated set of developer tools that we KDE developers decided to include. Want something else? There's a wiki page with suggestions for installation mechanisms we don't officially support—mechanisms that, let's be real, most of us don't even use ourselves.</p>

<p>This sets us up for the same reputation trap that caught KDE Neon:</p>

<blockquote>Just like KDE Neon got pigeonholed with the reputation of being "for testing KDE software," KDE Linux risks getting branded as "for developing KDE software only."</blockquote>

<p>There's also a deeper inconsistency here. One of the stated goals is making the end user's system exactly the same as our development systems. But if the tools we actually use day-to-day are already baked into the base image—and thus not part of the extensibility model we're asking users to adopt—then we're not eating our own dog food. We're shipping an experience we don't fully use ourselves.</p>

<h2 style="text-align: left;">The Solution</h2>

<div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhCV4OlKrOrU9trXMW5ZyzcSNZ_1pEKNRvVsMGkskJMZuRDSA7kampDy_TMf4Cz1mMhvKm_FzLhzwzIqCE16H5BEgHHTV3mBLwDHTPjUdIvaXikUXdfQa6loh0_WBG8sFQJv6yugIVF7vnVWtaHVWqdLHjo2qCO0OSQYQ27ceLBU-1ygwm3zJMq27KvJu4/s3008/whale.jpg" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="2000" data-original-width="3008" height="213" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhCV4OlKrOrU9trXMW5ZyzcSNZ_1pEKNRvVsMGkskJMZuRDSA7kampDy_TMf4Cz1mMhvKm_FzLhzwzIqCE16H5BEgHHTV3mBLwDHTPjUdIvaXikUXdfQa6loh0_WBG8sFQJv6yugIVF7vnVWtaHVWqdLHjo2qCO0OSQYQ27ceLBU-1ygwm3zJMq27KvJu4/s320/whale.jpg" width="320" /></a></div><br />

<p>Look at the wild success of Docker and Kubernetes. Their container-based approach proved that immutable infrastructure actually works at scale. That success paved the way for Flatpak and Snap to become the de facto solution for GUI apps, and now we're seeing immutable base systems everywhere. The lesson is clear: containers aren't just one solution among many—they're the foundation that makes immutable systems viable.</p>

<h3 style="text-align: left;">Containers for CLI Tools???</h3>

<p>As crazy as it sounds, that's the logical next step. Let's look at the candidates to base our solution on top of:</p>

<p><b>distrobox/toolbox</b> are trying to solve the right problem—building long-term, persistent development environments—but they're doing it on top of docker/podman, which were designed for ephemeral containers. They're essentially fighting against the grain of their underlying systems. Every time you want to do something that assumes persistence and state, you're working around design decisions made for a different use case. It works, but you can feel the friction.</p>

<p><b>systemd-nspawn</b> is built for persistence from the ground up, which is exactly what we want. It has a proper init system, it's designed to be long-lived. The challenge here is that we need fine-grained control over the permissions model—specifically, we need to enable things like nested containers (running docker/podman inside the container) and exposing arbitrary hardware devices without a lot of manual configuration. systemd-nspawn makes these scenarios difficult by design, which is great for security but limiting for a flexible development environment.</p>

<p><b>devcontainers</b> nail the developer experience—they're polished, well-integrated, and they just work. The limitation is that they're designed to be used from an IDE like VS Code, not as a system-wide solution. We need something that integrates with the OS itself, not just with your editor. That said, there's definitely lessons to learn from how well they've executed on the developer workflow.</p>

<h3 style="text-align: left;">Our knight in shining armor:</h3>

<div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiNgS8ur871GuqzC7_Np_Fyfru4_1EwMmLr0JgxpemUHx6fFi_25sZu6IQI2LkSLjtBCprbMCP1avOz4eOD7EfOy9uLxe1yt7RRp6ICNS1NCx2e__ptRAx-T-6ED5ZUGptLqCcPxhoUm5PAtngxSHw3aGgQ1gWkbxR2cQ0N7Vv3mngof1ndGtJk2ObYOH4/s1024/incus-hero3.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="1024" data-original-width="1024" height="320" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiNgS8ur871GuqzC7_Np_Fyfru4_1EwMmLr0JgxpemUHx6fFi_25sZu6IQI2LkSLjtBCprbMCP1avOz4eOD7EfOy9uLxe1yt7RRp6ICNS1NCx2e__ptRAx-T-6ED5ZUGptLqCcPxhoUm5PAtngxSHw3aGgQ1gWkbxR2cQ0N7Vv3mngof1ndGtJk2ObYOH4/s320/incus-hero3.png" width="320" /></a></div><br />

<p>Enter <b>Incus</b>. It checks all the boxes:</p>

<ul>
<li><b>Proper API</b> for building tooling on top of it</li>
<li><b>Nested containers work out of the box</b>—want to run docker inside your Incus container? Go for it</li>
<li><b>Privileged container mode</b> for when you need full system access and hardware devices</li>
<li><b>Built on LXC</b>, which means it's designed for long-lived, system-level containers from day one, not retrofitted from ephemeral infrastructure</li>
</ul>

<p>Bonus: it supports VMs too, for running less trusted workloads. People on Matrix said they want this option. I don't fully get the use case for a development environment, but the flexibility is there if we need it.</p>

<h2 style="text-align: left;">Architecture</h2>

<p>Incus exposes a REST API with full OpenAPI specs—great for interoperability, but dealing with REST/OpenAPI in C++ is not something I'm eager to take on.</p>

<p>My first choice would be C#—it's a language I actually enjoy, and it handles this kind of API work beautifully. But I suspect the likelihood of KDE developers accepting C# code into the project is... low.</p>

<p>Languages that already build in kde-builder and CMake will probably have the least friction for acceptance, and of those, Python is the best fit for this job.
The type system isn't as mature as I'd like (though at least it exists now with type hints), and the libraries for OpenAPI and D-Bus are... okay-ish. Not amazing, but workable.</p>

<p>Here's the plan:</p>
<ul>
<li><b>Daemon in Python</b> to handle all the Incus API interaction</li>
<li><b>CLI, KCM, and Konsole plugin in C++</b> for the user-facing pieces that integrate with the rest of KDE</li>
</ul>

<p>This way we keep the REST/OpenAPI complexity in Python where it's manageable, and the KDE integration in C++ where it belongs.</p>

<h2 style="text-align: left;">Current Status</h2>

<p>Look, the KDE "K" naming thing is awesome. I'm not going to pretend otherwise. My first instinct was "Kontainer"—obvious, descriptive, checks the K box. Unfortunately, it was already taken.</p>

<p>So I went with <b>Kapsule</b>. It's a container. It encapsulates things. The K is there. Works for me.</p>

<p>The implementation is currently in a repo under my user namespace at <a href="https://invent.kde.org/fernando/kapsule">fernando/kapsule</a>. But I have a ticket open with the sysadmin team to move this into <span style="font-family: monospace;">kde-linux/kapsule</span>. Once that's done I'll be able to add it to kde-builder and start integrating it into the KDE Linux packages pipeline.</p>

<p>The daemon and CLI are functional. Since a picture is worth a thousand words, here's a screenshot of the CLI in action:</p>

<div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhed88StgwinBgvOgjNbGCGGciE6GQEOEQKBGKB7FTfDxo0vOMw5tbXxf-wVZijVCwK-TAuDSBqIYDhS_mWeENdpSpFEFHcjXFaV_FdtdZM9eaKSawqy_rX-bAteI9mdlsRHEv76W1hqUuH9EcGUnVd_4pHK59THQ924WnBWkRK7E2tiJTkM_EITa_PQz0/s1109/kap_cli_screenshot.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="1036" data-original-width="1109" height="299" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhed88StgwinBgvOgjNbGCGGciE6GQEOEQKBGKB7FTfDxo0vOMw5tbXxf-wVZijVCwK-TAuDSBqIYDhS_mWeENdpSpFEFHcjXFaV_FdtdZM9eaKSawqy_rX-bAteI9mdlsRHEv76W1hqUuH9EcGUnVd_4pHK59THQ924WnBWkRK7E2tiJTkM_EITa_PQz0/s320/kap_cli_screenshot.png" width="320" /></a></div><br />

<p>Here's docker and podman running inside ubuntu and fedora containers, respectively:</p>

<div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhBlgz1fb11fHU1upIZpa-nSKMUkCeQ_y7371LH09pWgbiwDE0jZiPpdEIJ6urvRaRT9CnhRMsCt8Ge4PapE4xKngZOsARJY_tGxV6tq5Vl_X_NMYZyLfQi5gaLbqLmj2myZKPQOwFwPHL57cJe57dhPa-TM9ucJoOwbcv5UWgdUXKDoiMBYBQrhBOu-bE/s1033/docker_podman.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="751" data-original-width="1033" height="233" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhBlgz1fb11fHU1upIZpa-nSKMUkCeQ_y7371LH09pWgbiwDE0jZiPpdEIJ6urvRaRT9CnhRMsCt8Ge4PapE4xKngZOsARJY_tGxV6tq5Vl_X_NMYZyLfQi5gaLbqLmj2myZKPQOwFwPHL57cJe57dhPa-TM9ucJoOwbcv5UWgdUXKDoiMBYBQrhBOu-bE/s320/docker_podman.png" width="320" /></a></div><br />

<p>And here's chromium running inside the container, screencasting the host's desktop:</p>

<div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiBM7dhlqgGquygw43SBE_X2RqJh_TPCjlIFISCFD-wpvp0WHB-JDN6JmJp-YcVP8i2AfMpH0i3ZwBUmZSxJNpcxk9p9apcvN6VcozJ33tVfKc_A3FeeBBVr4GIh_OedYhvshGhc1GUnVPM1EqOyej_AJFAewxbBllEHr8QqZx3oHtsxJaiqAIfIpGseB0/s1862/chromium_screen_sharing.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="1247" data-original-width="1862" height="214" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiBM7dhlqgGquygw43SBE_X2RqJh_TPCjlIFISCFD-wpvp0WHB-JDN6JmJp-YcVP8i2AfMpH0i3ZwBUmZSxJNpcxk9p9apcvN6VcozJ33tVfKc_A3FeeBBVr4GIh_OedYhvshGhc1GUnVPM1EqOyej_AJFAewxbBllEHr8QqZx3oHtsxJaiqAIfIpGseB0/s320/chromium_screen_sharing.png" width="320" /></a></div><br />

<h2 style="text-align: left;">Next Steps</h2>

<h3 style="text-align: left;">Deeper integration</h3>

<p>Right now, Kapsule is a CLI that you have to manually invoke, and it lives kind of separately from the rest of the system. That's fine for a proof of concept, but the real value comes from making it invisible to users who just want things to work.</p>

<h4 style="text-align: left;">Konsole</h4>

<p>Konsole gained container integration in <a href="https://invent.kde.org/utilities/konsole/-/merge_requests/1171">!1171</a>, so I just need to create and add an <span style="font-family: monospace;">IContainerDetector</span> for Kapsule. Once that's wired up, I'll add a per-distro configurable option to open terminals in the designated container by default.</p>

<p>When Kapsule is stable enough, that becomes the default behavior. Users won't have to know or care about Kapsule—they just open a terminal and their tools are there. Unless they break their container, which leads nicely to the next point...</p>

<h4 style="text-align: left;">KCM</h4>

<p>A System Settings module for container management:</p>
<ul>
<li>Create, delete, start, stop containers</li>
<li>Easy reset if you ran something that broke things</li>
<li>For advanced users: configuration options like which distro to use, resource limits, etc.</li>
</ul>

<h4 style="text-align: left;">Discover</h4>

<p>These containers need to be kept up to date. Most will have PackageKit inside them, so we can create a Discover plugin that connects to the container's D-Bus session and shows updates for the container's packages alongside the host's updates. Seamless.</p>

<h3 style="text-align: left;">Moving dev tools out of the base image</h3>

<p>This is the long-term goal: get Kapsule stable and good enough that we can remove ZSH, git, clang, gcc, docker, podman, distrobox, toolbox, and the rest of the dev tools from the base image entirely. All of those already work in Kapsule.</p>

<p>Once that happens, we're eating our own dog food. The extensibility model we're asking users to adopt is the same one we're using ourselves.</p>

<h3 style="text-align: left;">Pimped out container images</h3>

<p>We'll maintain our own image repository. There's no real limit to the number of images we can offer, and everyone in the <a href="https://matrix.to/#/#kde-linux:kde.org">#kde-linux</a> channel can show off their style. Want a minimal Arch-based dev container? A fully-loaded Fedora workstation? A niche distro for embedded development? A Nix-based image (I'm looking at you, Hadi Chokr)? All possible.</p>

<h2 style="text-align: left;">Trying it out</h2>

<p>Honestly, the best way to try it out is to wait for me to get it integrated into the KDE Linux packages pipeline and into the base image itself.
Hopefully that'll be in the next few days.</p>
