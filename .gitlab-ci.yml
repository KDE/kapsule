# SPDX-FileCopyrightText: None
# SPDX-License-Identifier: CC0-1.0

include:
  - project: sysadmin/ci-utilities
    file:
      - /gitlab-templates/reuse-lint.yml
      - /gitlab-templates/linux-qt6.yml
      - /gitlab-templates/linux-qt6-next.yml

# ============================================================================
# Python Daemon Linting
# ============================================================================
# The KDE CI templates handle the C++ build (libkapsule-qt, kapsule CLI).
# These custom jobs lint/typecheck the Python daemon (src/daemon/).

.python_base:
  image: python:3.14-slim
  stage: build
  tags:
    - Linux
  interruptible: true
  before_script:
    - pip install --quiet --upgrade pip
    - pip install --quiet .[dev]

python_lint:
  extends: .python_base
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH
  script:
    - ruff check src/daemon/ tests/
    - ruff format --check src/daemon/ tests/

python_typecheck:
  extends: .python_base
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH
  script:
    - mypy src/daemon/

# ============================================================================
# Sysext Build (KDE Linux VM)
# ============================================================================
# Builds the full kapsule sysext (C++ components + Python daemon + vendored
# deps) on an Arch Linux VM and uploads it as an artifact for integration tests.

build_sysext:
  stage: build
  tags:
    - VM
    - amd64
  image: storage.kde.org/vm-images/kde-linux-builder
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH
  script:
    # Install build dependencies
    - sudo pacman -Syu --noconfirm
        base-devel cmake ninja extra-cmake-modules
        python python-pip
        qt6-base ki18n kcoreaddons kconfig qcoro-qt6
    - pip install --break-system-packages
        dbus-fast pydantic pyyaml httpx

    # Build and install to staging directory
    - cmake -B build -G Ninja
        -DCMAKE_INSTALL_PREFIX=/usr
        -DBUILD_KDE_COMPONENTS=ON
        -DINSTALL_PYTHON_DAEMON=ON
        -DVENDOR_PYTHON_DEPS=ON
    - cmake --build build
    - DESTDIR="${CI_PROJECT_DIR}/sysext" cmake --install build

    # Extension-release metadata (ID=_any so any base OS accepts it)
    - mkdir -p sysext/usr/lib/extension-release.d
    - echo "ID=_any" > sysext/usr/lib/extension-release.d/extension-release.kapsule

    # Package as a sysext tarball
    - tar -cf kapsule.sysext.tar -C sysext usr
  artifacts:
    paths:
      - kapsule.sysext.tar
    expire_in: 1 week

# ============================================================================
# Integration Tests (KDE Linux VM)
# ============================================================================
# Boots a KDE Linux builder VM, deploys the sysext, sets up incus, and runs
# the full integration test suite.

integration_test:
  stage: test
  tags:
    - VM
    - amd64
  image: storage.kde.org/vm-images/kde-linux-builder
  needs:
    - build_sysext
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH
  variables:
    KAPSULE_TEST_VM: localhost
  script:
    # ---- Install runtime dependencies ----
    # incus pulls in iptables-nft which conflicts with iptables on the base image;
    # --ask 4 tells pacman to auto-resolve conflicts by replacing the old package.
    # Runtime libs needed by the kapsule CLI (linked against Qt6, KF6, QCoro).
    - sudo pacman -Syu --noconfirm --ask 4
        incus openssh
        qt6-base ki18n kcoreaddons kconfig qcoro-qt6
        python python-pip python-pytest python-pytest-asyncio
    - pip install --break-system-packages
        dbus-fast pydantic pyyaml httpx

    # ---- Deploy sysext from build artifact ----
    - sudo mkdir -p /var/lib/extensions/kapsule
    - sudo tar -xf kapsule.sysext.tar -C /var/lib/extensions/kapsule
    - sudo systemd-sysext refresh
    - sudo systemctl daemon-reload
    - sudo systemctl reload dbus.service

    # ---- Verify sysext deployment ----
    - echo "=== Sysext status ==="
    - systemd-sysext status
    - echo "=== Kapsule files installed ==="
    - 'ls -la /usr/lib/systemd/system/kapsule-daemon.service || echo "WARNING: daemon service file missing"'
    - 'ls -la /usr/share/dbus-1/system.d/org.kde.kapsule.conf || echo "WARNING: D-Bus policy file missing"'
    - 'which kapsule || echo "WARNING: kapsule CLI not on PATH"'
    - 'kapsule --help 2>&1 | head -5 || echo "WARNING: kapsule CLI not working"'

    # ---- Start incus ----
    - echo "$(date -Iseconds) [DEBUG] Checking incus binary..."
    - which incus && incus --version
    - echo "$(date -Iseconds) [DEBUG] Checking kernel modules for incus..."
    - lsmod | grep -E 'btrfs|zfs|loop|overlay|br_netfilter|nf_nat' || echo "(no matching kernel modules loaded)"
    - echo "$(date -Iseconds) [DEBUG] Checking available storage backends..."
    - 'ls -la /dev/loop* 2>/dev/null | head -5 || echo "(no loop devices)"'
    - echo "$(date -Iseconds) [DEBUG] Starting incus.socket..."
    - sudo systemctl start incus.socket
    - echo "$(date -Iseconds) [DEBUG] incus.socket started (exit=$?)"
    - sudo systemctl status incus.socket --no-pager || true
    - echo "$(date -Iseconds) [DEBUG] Starting incus.service..."
    - sudo systemctl start incus.service &
    - |
      INCUS_PID=$!
      for i in $(seq 1 30); do
        if ! kill -0 "$INCUS_PID" 2>/dev/null; then
          echo "$(date -Iseconds) [DEBUG] incus.service start command finished after ${i}s"
          wait "$INCUS_PID" || true
          break
        fi
        echo "$(date -Iseconds) [DEBUG] Waiting for incus.service to start (${i}/30)..."
        sleep 1
      done
      if kill -0 "$INCUS_PID" 2>/dev/null; then
        echo "$(date -Iseconds) [WARNING] incus.service start still running after 30s, continuing..."
      fi
    - echo "$(date -Iseconds) [DEBUG] incus.service unit state:"
    - sudo systemctl status incus.service --no-pager || true
    - echo "$(date -Iseconds) [DEBUG] incus.service journal (last 30 lines):"
    - 'sudo journalctl -u incus.service --no-pager -n 30 2>&1 || echo "(journalctl failed)"'
    - echo "$(date -Iseconds) [DEBUG] Checking incus socket file..."
    - 'ls -la /var/lib/incus/unix.socket 2>/dev/null || echo "WARNING: socket does not exist yet"'
    - echo "$(date -Iseconds) [DEBUG] Running incus admin init --minimal..."
    - timeout 30 sudo incus admin init --minimal || { echo "$(date -Iseconds) [ERROR] incus admin init timed out or failed (exit=$?)"; sudo journalctl -u incus.service --no-pager -n 50; }
    - echo "$(date -Iseconds) [DEBUG] incus admin init completed"
    # Grant the CI user access to the incus socket directly (usermod -aG
    # does not take effect until a new login session).
    - sudo chmod 0666 /var/lib/incus/unix.socket

    # ---- Verify incus ----
    - echo "$(date -Iseconds) [DEBUG] === Incus status ==="
    - timeout 10 incus version || echo "$(date -Iseconds) [ERROR] incus version timed out"
    - timeout 10 incus list || echo "$(date -Iseconds) [ERROR] incus list timed out"
    - ls -la /var/lib/incus/unix.socket
    - echo "$(date -Iseconds) [DEBUG] Incus storage pools:"
    - timeout 10 incus storage list || echo "(no storage pools)"
    - echo "$(date -Iseconds) [DEBUG] Incus networks:"
    - timeout 10 incus network list || echo "(no networks)"
    - echo "$(date -Iseconds) [DEBUG] Incus verification complete"

    # ---- Start kapsule daemon ----
    - sudo systemctl start kapsule-daemon.service

    # Wait for the daemon to register on D-Bus
    - |
      for i in $(seq 1 15); do
        busctl status org.kde.kapsule &>/dev/null && break
        echo "  waiting for D-Bus registration ($i/15)..."
        sleep 1
      done
      busctl status org.kde.kapsule

    # ---- Verify daemon is working ----
    - echo "=== Daemon service status ==="
    - sudo systemctl status kapsule-daemon.service --no-pager || true
    - echo "=== D-Bus introspection ==="
    - busctl tree org.kde.kapsule || true

    # ---- Set up SSH to localhost for the test harness ----
    # Tests SSH as current user and some tests SSH as root.
    - sudo systemctl enable --now sshd
    - mkdir -p ~/.ssh && chmod 700 ~/.ssh
    - ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519 -N ""
    - cat ~/.ssh/id_ed25519.pub >> ~/.ssh/authorized_keys
    - chmod 600 ~/.ssh/authorized_keys
    - ssh-keyscan -H localhost >> ~/.ssh/known_hosts 2>/dev/null
    - sudo mkdir -p /root/.ssh && sudo chmod 700 /root/.ssh
    - sudo cp ~/.ssh/id_ed25519.pub /root/.ssh/authorized_keys
    - sudo chmod 600 /root/.ssh/authorized_keys

    # ---- Verify SSH ----
    - ssh -o StrictHostKeyChecking=no localhost "echo 'SSH to localhost works'"

    # ---- Inline smoke + audio socket validation ----
    - |
      set -euo pipefail

      CONTAINER_NAME="test-audio-inline-smoke"
      TEST_IMAGE="images:archlinux"
      uid="$(id -u)"

      cleanup() {
        incus delete "$CONTAINER_NAME" --force 2>/dev/null || true
      }
      trap cleanup EXIT

      echo "=== Smoke: create container ==="
      kapsule create "$CONTAINER_NAME" --image "$TEST_IMAGE"

      echo "=== Smoke: verify container state ==="
      incus info "$CONTAINER_NAME"
      incus list

      echo "=== Smoke: verify incus exec path ==="
      echo "Running: timeout 30 incus exec $CONTAINER_NAME -- true"
      set +e
      timeout 30 incus exec "$CONTAINER_NAME" -- true
      incus_exec_rc=$?
      set -e
      echo "incus exec smoke exit code: $incus_exec_rc"

      echo "=== Smoke: verify kapsule enter path ==="
      echo "Running: timeout 30 kapsule enter $CONTAINER_NAME -- true"
      set +e
      timeout 30 kapsule enter "$CONTAINER_NAME" -- true
      enter_rc=$?
      set -e
      echo "kapsule enter smoke exit code: $enter_rc"

      if [ "$incus_exec_rc" -eq 0 ] && [ "$enter_rc" -ne 0 ]; then
        echo "ERROR: incus exec succeeded but kapsule enter failed (likely kapsule-specific issue)"
        echo "=== Diagnostics: incus info ==="
        incus info "$CONTAINER_NAME" || true
        echo "=== Diagnostics: container log ==="
        incus info "$CONTAINER_NAME" --show-log || true
        exit 1
      fi

      if [ "$incus_exec_rc" -ne 0 ]; then
        echo "ERROR: incus exec smoke command failed or timed out"
        echo "=== Diagnostics: incus info ==="
        incus info "$CONTAINER_NAME" || true
        echo "=== Diagnostics: container log ==="
        incus info "$CONTAINER_NAME" --show-log || true
        exit 1
      fi

      if [ "$enter_rc" -ne 0 ]; then
        echo "ERROR: kapsule enter smoke command failed or timed out"
        echo "=== Diagnostics: incus info ==="
        incus info "$CONTAINER_NAME" || true
        echo "=== Diagnostics: container log ==="
        incus info "$CONTAINER_NAME" --show-log || true
        exit 1
      fi

      echo "=== Audio: checking runtime sockets ==="
      if test -S "/run/user/$uid/pipewire-0"; then
        timeout 20 kapsule enter "$CONTAINER_NAME" -- test -S "/run/user/$uid/pipewire-0"
        echo "PipeWire socket is available in container"
      else
        echo "PipeWire socket not found on host (skipping passthrough check)"
      fi

      if test -S "/run/user/$uid/pulse/native"; then
        timeout 20 kapsule enter "$CONTAINER_NAME" -- test -d "/run/user/$uid/pulse"
        timeout 20 kapsule enter "$CONTAINER_NAME" -- test -S "/run/user/$uid/pulse/native"
        echo "PulseAudio socket is available in container"
      else
        echo "PulseAudio socket not found on host (skipping passthrough check)"
      fi

      echo "=== Audio: checking hostfs socket visibility ==="
      if timeout 20 kapsule enter "$CONTAINER_NAME" -- test -S "/.kapsule/host/run/user/$uid/pipewire-0"; then
        echo "Host PipeWire socket visible via hostfs"
      else
        echo "Host PipeWire socket not visible via hostfs (may not be running)"
      fi

      if timeout 20 kapsule enter "$CONTAINER_NAME" -- test -d "/.kapsule/host/run/user/$uid/pulse"; then
        echo "Host PulseAudio directory visible via hostfs"
      else
        echo "Host PulseAudio directory not visible via hostfs (may not be running)"
      fi

      echo "=== Audio: tool-level checks (best effort) ==="
      if timeout 180 kapsule enter "$CONTAINER_NAME" -- sudo pacman -Syu --noconfirm libpulse pipewire; then
        if timeout 20 kapsule enter "$CONTAINER_NAME" -- pactl info; then
          echo "pactl info succeeded"
        else
          echo "pactl info failed"
          exit 1
        fi

        if timeout 20 kapsule enter "$CONTAINER_NAME" -- pw-cli info 0; then
          echo "pw-cli info succeeded"
        else
          echo "pw-cli info failed"
          exit 1
        fi
      else
        echo "Failed to install audio tools in container"
        exit 1
      fi

      echo "=== Smoke: cleanup ==="
      kapsule rm "$CONTAINER_NAME" --force
      trap - EXIT
  after_script:
    - |
      set +e
      echo "=== Collecting diagnostic logs ==="
      echo "--- kapsule-daemon.service journal ---"
      sudo -n journalctl -u kapsule-daemon.service --no-pager -n 200 2>&1 || echo "(journalctl for kapsule-daemon failed)"
      echo "--- incus.service journal ---"
      sudo -n journalctl -u incus.service --no-pager -n 50 2>&1 || echo "(journalctl for incus failed)"
      echo "--- systemctl status kapsule-daemon ---"
      sudo -n systemctl status kapsule-daemon.service --no-pager 2>&1 || echo "(systemctl status failed)"
      echo "--- incus container list ---"
      incus list 2>&1 || echo "(incus list failed)"
      echo "--- test container logs (if any) ---"
      for c in $(incus list -c n -f csv 2>/dev/null | grep "^test-" || true); do
        echo "=== incus info $c ==="
        incus info "$c" 2>&1 || true
      done
      echo "--- dmesg (last 30 lines) ---"
      sudo -n dmesg --time-format=iso | tail -30 2>&1 || echo "(dmesg failed)"
      echo "--- sysext status ---"
      systemd-sysext status 2>&1 || echo "(sysext status failed)"
      echo "=== End diagnostic logs ==="
      exit 0
